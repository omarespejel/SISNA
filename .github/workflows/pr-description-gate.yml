name: PR Description Gate

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]
  merge_group:
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: read

jobs:
  pr_description_gate:
    name: PR description gate
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR description
        uses: actions/github-script@v7
        with:
          script: |
            function normalize(s) {
              return (s || '').replace(/\r\n/g, '\n');
            }

            function hasHeading(body, heading) {
              const re = new RegExp(`^##\\s+${heading.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\s*$`, 'im');
              return re.test(body);
            }

            function sectionText(body, heading) {
              const esc = heading.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');
              const re = new RegExp(`^##\\s+${esc}\\s*$([\\s\\S]*?)(?=^##\\s+|$)`, 'im');
              const m = body.match(re);
              return m ? m[1].trim() : '';
            }

            function matchBoundary(files, patterns) {
              return files.some((f) => patterns.some((p) => {
                if (p.endsWith('/')) return f.startsWith(p);
                if (p.endsWith('/**')) return f.startsWith(p.slice(0, -3));
                return f === p;
              }));
            }

            async function loadConfigFromBaseRef(baseRef) {
              const res = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.github/pr-body-lint.json',
                ref: baseRef
              });

              const file = Array.isArray(res.data) ? null : res.data;
              if (!file || !file.content) throw new Error('Unable to load .github/pr-body-lint.json from base ref');

              const raw = Buffer.from(file.content, 'base64').toString('utf8');
              return JSON.parse(raw);
            }

            async function prNumbersFromEvent() {
              const eventName = context.eventName;
              if (eventName === 'pull_request') return [context.payload.pull_request.number];

              try {
                const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: context.sha
                });
                const nums = (prs.data || []).map((p) => p.number).filter(Boolean);
                if (nums.length) return [...new Set(nums)];
              } catch (e) {
                core.warning(`Could not list PRs associated with commit ${context.sha}: ${e.message}`);
              }

              const payloadPrs = (context.payload && context.payload.pull_requests) || [];
              const nums2 = payloadPrs.map((p) => p.number).filter(Boolean);
              return [...new Set(nums2)];
            }

            async function listChangedFiles(prNumber) {
              const files = [];
              let page = 1;
              while (true) {
                const res = await github.rest.pulls.listFiles({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  per_page: 100,
                  page
                });
                for (const f of res.data) files.push(f.filename);
                if (res.data.length < 100) break;
                page += 1;
              }
              return files;
            }

            function fail(msg) {
              core.setFailed(msg);
            }

            const prNumbers = await prNumbersFromEvent();
            if (!prNumbers.length) {
              fail('Unable to determine PR number(s) for this event; refusing to pass.');
              return;
            }

            const failures = [];

            for (const prNumber of prNumbers) {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              const author = (pr.data.user && pr.data.user.login) ? pr.data.user.login : '';
              if (author === 'dependabot[bot]') {
                core.info(`Skipping PR description gate for dependabot PR #${prNumber}.`);
                continue;
              }

              const config = await loadConfigFromBaseRef(pr.data.base.sha);
              const body = normalize(pr.data.body || '');
              const title = pr.data.title || `#${prNumber}`;
              const changedFiles = await listChangedFiles(prNumber);

              for (const h of config.requiredHeadings || []) {
                if (!hasHeading(body, h)) failures.push(`${title}: missing required section '## ${h}'`);
              }

              if (!/^\s*Spec impact\s*:/im.test(body)) failures.push(`${title}: missing 'Spec impact:' line under '## Spec impact'`);

              const touchesBoundary = matchBoundary(changedFiles, config.boundaryPatterns || []);
              const crossRepo = hasHeading(body, 'Cross-repo impact') ? sectionText(body, 'Cross-repo impact') : '';

              if (touchesBoundary) {
                if (!crossRepo) failures.push(`${title}: boundary files changed but '## Cross-repo impact' is empty/missing`);
                const missingRepos = (config.counterpartRepos || []).filter((r) => !crossRepo.includes(r));
                if (missingRepos.length) failures.push(`${title}: boundary files changed; Cross-repo impact must mention: ${missingRepos.join(', ')}`);
              }
            }

            if (failures.length) {
              fail(`PR description gate failed:\\n- ${failures.join('\\n- ')}`);
            } else {
              core.info('PR description gate passed.');
            }
